{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"剖析Promise内部结构，手写Promise","text":"Promise标准 只有一个then方法，没有catch、race、all等方法，甚至没有指定该如何构造出一个Promise对象，另外then也没有一般实现中（如Q、$q等）所支持的第三参数，一般成为onProgress then方法返回一个新的Promise，而不是返回this 不同的Promise的实现需要可以互相调用 Promise的初始状态为pending，可以由此状态转换为fulfilled（即resolved或rejected）。状态一旦确定，就无法转换为其他状态，状态确定的过程为settle Promise标准文档 手写Promise用构造函数的方式构造一个Promise对象，也是ES6原生Promise所用方式 1234567891011121314151617181920212223function Promise(executor) { const self = this; self.status = 'pending' self.data = undefined self.onRsolvedCallback = [] self.onRejectedCallback = [] function resolved(value) { } function reject(value) { } try{ executor(resolve, reject) } catch(e) { reject(e) }} 实现 resolved 和 reject 两个函数12345678910111213141516171819202122232425function Promise(exectour) { //... function resolved(value) { if(self.status === 'pending') { self.status = 'resolved' self.data = value for(let i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](value) } } } function reject(reason) { if(self.status === 'pending') { self.status = 'rejected' self.data = reason for(let i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason) } } } //...} then方法因为调用方式为.then，所以then方法需要写在原型上。标准中then需要返回一个新的Promise对象。另外Promise对象可以链式调用then方法，所以调用then返回的Promise状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为每次返回的Promise状态都有可能不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Promise.prototype.then = function(onResolved, onRejected) { const self = this const promise2 = null //根据标准，如果then的参数不是function，则直接忽略 onResolved = typeof onResolved === 'function' ? onResolved : function(value) {} onRejected = typeof onRejected === 'function' ? onRejected : function(value) {} if(self.status === 'resolved') { return promise2 = new Promise(function(resolve, reject)) { try { const x = onResolved(self.data) if(x instanceof Promise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果为promise2的结果 x.then(resolve, reject) } // 否则，以它的返回值做为promise2的结果 resolve(x) } catch (e) { // 若出错，以捕获的错误做为promise2的结果 reject(e) } } } // 此处与resolve的逻辑几乎相同 if(self.status === 'rejected') { return promise2 = new Promise(function(resolve, reject) { try { const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) } if(self.status === 'pending') { // 如果当前Promise还处于pending状态，并不能确定调用onResolve还是onRejected，只能等到Promise的状态确定之后，才能确定如何处理。 // 所以我们需要把我们的两种情况的处理逻辑做为callback 放入 promise1的回调数组里 return promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { const x = onResolved(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) self.onRejectedCallback.push(function(reason) { try{ const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch (e) { reject(e) } }) }) }} 处理两个问题1、Promise值的穿透，例如： 123456new Promise(resolve =&gt; resolve(8)) .then() .catch() .then(function foo(value) { alter(value) }) 解决方案：以上代码转换为： 12345678910new Promise（resolve =&gt; resolve(8)） .then(function(value) { return value }) .catch(function(reason) { throw reason }) .then(function foo(value) { alter(value) }) 若想要把then的实参，留空且让值穿透，只需要修改then的两个参数默认值分别如下： 1function(value) { return value }, function(reason) { return reason }; 体现到then，则如下： 12onResolved = typeof onResolved === 'function' ? onResolved : function(value) { return value }onRejected = typeof onRejected === 'function' ? onRejected : function(reason) { throw reason } 2、不同的Promise实现之间需要无缝的可交互，如： 12345678910111213141516// 此处用MyPromise来代表我们实现的Promisenew MyPromise(function(resolve, reject) { // 我们实现的Promise setTimeout(function() { resolve(42) }, 2000)}).then(() =&gt; { return new Promise.reject(2) // ES6的Promise}).then(function() { return Q.all([ // Q的Promise new MyPromise(resolve =&gt; resolve(8)); // 我们实现的Promise new Promise.resolve(9); // ES6的Promise Q.resolve(9); // Q的Promise ])}) 这里简单解释下标准：即我们要把onResolved/onRejected的返回值——x，当成一个可能是Promise对象，也即标准里所说的thenable，并以最保险的方法调用x上的then方法，如果大家都按照标准实现，那么不同的Promise之间就可以交互了。而标准为了保险起见，即使x返回了一个带有then属性，但并不遵循Promise标准的对象（比如说这个x把它then里的两个参数都调用了，同步或者异步调用，或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。 resolvePromise函数即为根据x的值来决定promise2的状态的函数，也即标准中的Promise Resolution Procedurex为promise2 = promise1.then(onResolved, onRejected)里onResolved/onRejected的返回值，resolve和reject实际上是promise2的executor的两个实参，因为很难挂在其它的地方，所以一并传进来。相信各位一定可以对照标准把标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function resolvePromise(promise2, x, resolve, reject) { var then var thenCalledOrThrow = false if (promise2 === x) { // 对应标准2.3.1节 return reject(new TypeError('Chaining cycle detected for promise!')) } if(x instanceof Promise) { // 对应标准2.3.2节 // 如果x的状态还没确定，那么它是有可能被一个thenable决定最终状态和值的 // 所以这里需要做一下处理，而不能一概的以为它会被一个“正常”的值resolve if(x.status === 'pending') { x.then(function(value) { resolvePromise(promise2, value, resolve, reject) }, reject) } else { // 但如果这个Promise的状态已经确定了，那么它肯定有一个“正常”的值，而不是一个thenable，所以这里直接取它的状态 x.then(resolve, reject) } return } if ((x !== null) &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) { // 2.3.3 try { // 2.3.3.1 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用 // 即要判断它的类型，又要调用它，这就是两次读取 then = x.then if (typeof then === 'function') { // 2.3.3.3 then.call(x, function rs(y) { // 2.3.3.3.1 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return resolvePromise(promise2, y, resolve, reject) // 2.3.3.3.1 }, function rj(r) { // 2.3.3.3.2 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return reject(r) }) } else { // 2.3.3.4 resolve(x) } } catch (e) { // 2.3.3.2 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return reject(e) } } else { // 2.3.4 resolve(x) }} 最后，原则上，promise.then(onResolved, onRejected)里的这两项函数需要异步调用，关于这一点，标准里也有说明：In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack.所以我们需要对代码做一些改动，即在四个地方加上setTimeout(fn, 0), 这点会在完整的代码中注释。 至此，已经完整实现一个Promise，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165try { module.exports = Promise} catch(e) {}function Promise(executor) { var self = this self.status = 'pending' self.onResolvedCallback = [] self.onRejectedCallback = [] function resolve(value) { if(value instanceof Promise) { return value.then(resolve, reject) } setTimeout(function() { if(self.status === 'pending') { self.status = 'resolved' self.data = value for(var i = 0; i &lt; self.onResolvedCallback; i++) { self.onResolvedCallback[i](value) } } }) } function reject(reason) { setTimeout(() =&gt; { if(self.status === 'pending') { self.status = 'rejected' self.data = reason for(var i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason) } } }) } try{ executor(resolve, reject) } catch(reason) { reject(reason) }}function resolvePromise(promise2, x, resolve, reject) { var then var thenCalledOrThrow = false if (promise2 === x) { return reject(new TypeError('Chaining cycle detected for promise!')) } if (x instanceof Promise) { if (x.status === 'pending') { //because x could resolved by a Promise Object x.then(function(v) { resolvePromise(promise2, v, resolve, reject) }, reject) } else { //but if it is resolved, it will never resolved by a Promise Object but a static value; x.then(resolve, reject) } return } if ((x !== null) &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) { try { then = x.then //because x.then could be a getter if (typeof then === 'function') { then.call(x, function rs(y) { if (thenCalledOrThrow) return thenCalledOrThrow = true return resolvePromise(promise2, y, resolve, reject) }, function rj(r) { if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(r) }) } else { resolve(x) } } catch (e) { if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(e) } } else { resolve(x) }}Promise.prototype.then = function(onResolved, onRejected) { var self = this var promise2 onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return v } onRejected = typeof onRejected === 'function' ? onRejected : function(r) { throw r } if (self.status === 'resolved') { return promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onResolved try { var x = onResolved(self.data) resolvePromise(promise2, x, resolve, reject) } catch (reason) { reject(reason) } }) }) } if (self.status === 'rejected') { return promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onRejected try { var x = onRejected(self.data) resolvePromise(promise2, x, resolve, reject) } catch (reason) { reject(reason) } }) }) } if (self.status === 'pending') { // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义 return promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { var x = onResolved(value) resolvePromise(promise2, x, resolve, reject) } catch (r) { reject(r) } }) self.onRejectedCallback.push(function(reason) { try { var x = onRejected(reason) resolvePromise(promise2, x, resolve, reject) } catch (r) { reject(r) } }) }) }}Promise.prototype.catch = function(onRejected) { return this.then(null, onRejected)}Promise.deferred = Promise.defer = function() { var dfd = {} dfd.promise = new Promise(function(resolve, reject) { dfd.resolve = resolve dfd.reject = reject }) return dfd} 最后我们来用20行写出一个简易版的Promise，支持异步链式调用 12345678910111213141516171819202122232425function Promise(fn) { this.cbs = []; const resolve = (value) =&gt; { setTimeout(() =&gt; { this.data = value; this.cbs.forEach((cb) =&gt; cb(value)); }); } fn(resolve);}Promise.prototype.then = function (onResolved) { return new Promise((resolve) =&gt; { this.cbs.push(() =&gt; { const res = onResolved(this.data); if (res instanceof Promise) { res.then(resolve); } else { resolve(res); } }); });}; 案例 1234567891011121314new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(1); }, 500);}) .then((res) =&gt; { console.log(res); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(2); }, 500); }); }) .then(console.log);","link":"/2022/03/09/Handwritten-Promise/"},{"title":"理解JavaScript之EventLoop","text":"前言异步背后的“靠山”就是Event Loop。这里的异步准确的说叫浏览器的Event Loop或者JavaScript运行环境的Event Loop，因为ECMAScript中没有Event Loop，Event Loop是在HTML Standard定义的。Event Loop是浏览器或Node解决单线程运行时不会阻塞的一种机制。规范中定义了浏览器何时进行渲染更新，了解它有助于性能优化. 定义Event Loop即事件循环，实现异步的一种方式。在HTML Standard中的定义章节： 为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用本节所述的event loop。 触发一个click事件，进行一次ajax请求，背后都有event loop在运作。 Task（macrotask， 宏任务） 一个Event Loop有一个或者多个task队列当用户代理安排一个任务，必须将该任务增加到相应的Event Loop的一个task队列中。每一个task都来源于指定的任务源，比如可以为鼠标、键盘事件提供一个task队列，其他时间又是一个单独的队列。可以为鼠标，键盘事件分配更多的时间，保证交互的流畅。 规范在Generic task sources中有提及哪些是task任务源： DOM操作任务源，用于相应dom操作，例如一个元素以非阻塞的方式插入文档。 用户交互任务源，用于对用户交互作出反应，例如键盘或鼠标输入。 网络任务源：用于相应网络活动。 history traversal 任务源，当调用history.back()等类似的api时，将任务插入task队列 总结，task任务源有哪些： setTimeout setInterval setImmediate I/O UI rendering microtask（微任务）每个Event Loop都有一个microtask队列，microtask会进入microtask队列，而不是task队列 如果在初期执行时，spin the event loop，microtasks有可能被移动到常规的task队列，在这种情况下，microtasks任务源会被task任务源所用。通常情况，task任务源和microtasks是不相关的。 microtask 和 macrotask队列相似之处：都是先进先出的队列，由指定任务源去提供任务。不同的是，一个Event Loop里只有一个microtask队列。 HTML Standard没有具体指明哪些是microtask任务源，通常认为是microtask任务源有： process.nextTick promises Object.observe MutationObserver Notes：在Promises/A+规范的Notes 3.1中提及了Promise的then方法可以采用macrotask 或者 microtask机制来实现。因此会产生promise在不同浏览器的差异。当然现在的共识都是 promise 都属于 microtask 队列。 深入了解有两种Event Loop，一种在浏览器上文，一种在workers中。每一个用户代理必须至少有一个浏览器上下文Event Loop，但是每个单元的相似源浏览器上下文至多有一个Event Loop。Event Loop总是具有至少一个浏览器上下文，当一个Event Loop的浏览器上下文全都销毁，Event Loop也会销毁。一个浏览器上下文总有一个Event Loop去协调它的活动。Worker的Event Loop相对简单一些，一个Worker对应一个Event Loop，Worker进程模型管理Event Loop的生命周期 浏览器上下文是一个将Document对象呈现给用户的环境。在一个Web浏览器内，一个标签页或窗口常包含一个浏览上下文，如一个iframe或一个frameset内的若干frame。 总结：每个线程都有自己的Event Loop。浏览器可以有多个Event Loop，Browsing Contexts和Web Workers就是相互独立的.所有同源的Browsing Contexts可以共用Event Loop，这样它们就可以互相通信。 Event Loop的循环过程在规范的Processing model定义了Event Loop的循环过程 在tasks队列中选择最老的一个task，用户代理可以选择任何task队列，如果没有可选的任务，则跳到下边的microtask步骤。 将上边选择的task设置为正在运行的task。 Run：运行被选择的task。 将Event Loop的currently running task 变为null。 从task队列里移除前边运行的task。 执行microtasks任务检查点。 更新渲染。 如果这是一个Worker EventLoop，但是没有任务在task队列中，并且WorkerGlobalScope对象的closing标识为true，则销毁event loop，中止这些步骤，然后进行定义在Web workers章节的run a worker。 返回第一步。 notes:执行完microtask队列里的任务，有可能会渲染更新。浏览器很聪明，在一帧以内的多次dom变动浏览器不会立即响应，而是会积攒变动以最高60HZ的频率更新视图。 microtask检查点以下为event loop运行第6步的详细步骤。 当用户代理去执行一个microtask checkpoint，如果microtask checkpoint的flag为false，用户代理必须运行下面的步骤： 将microtask checkpoint的flag设为true。 Microtask queue handling: 如果Event Loop的microtask为空，直接跳到第八步。 在microtask队列中选择最老的一个任务。 将上一步选择的任务设为Event Loop的currently running task 运行选择的任务。 将Event Loop的currently running task 变为null。 将前面运行的microtask从microtask队列中删除，然后返回第二步。 Done： 每一个environment settings object它们的 responsible event loop就是当前的event loop，会给environment settings object发一个 rejected promises 的通知。 清理IndexedDB的事务。 将microtask checkpoint的flag设为false。 什么时候会调用microtask checkpoint呢？ 当上下文执行栈为空，执行一个microtask checkpoint。 在Event Loop的第六步执行checkpoint，也就是在运行task之后，更新渲染之前。 执行栈task和microtask都是推入栈中执行的，要完整了解event loops还需要认识JavaScript execution context stack，它的规范位于https://tc39.github.io/ecma262/#execution-context-stack。 javaScript是单线程，也就是说只有一个主线程，主线程有一个栈，每一个函数执行的时候，都会生成新的execution context（执行上下文），执行上下文会包含一些当前函数的参数、局部变量之类的信息，它会被推入栈中， running execution context（正在执行的上下文）始终处于栈的顶部。当函数执行完后，它的执行上下文会从栈弹出。 完整异步过程打个比喻：主线程类似一个加工厂，只有一个条流水线（单线程），待执行的任务为原料，只有前一个加工完，才能进行后一个。eventLoop就是把原料放上流水线的工人。同步任务：只要已经放在流水线上的，它们会被依次处理。异步任务：待处理的原料，工人会按照它们的种类排序，在适当的时机放上流水线。 过程图： 举个栗子： 123456789101112131415Promise.resolve().then(function promise1() {console.log('promise1');})setTimeout(function() {console.log('setTimeout1');Promise.resolve().then(function promise2() {console.log('promise2');})}, 0)setTimeout(function setTimeout2() {console.log('setTimeout2')}, 0) 运行过程解析：第一步：task队列: [scipt]，microtask队列: [] script里的代码被列为一个task，放入task队列。 第二步：开始循环循环1： 从task队列中取出script任务，推入栈中执行。promise1列为microtask，setTimeout1列为task，setTimeout2列为task。task队列：[setTimeout1 setTimeout2], microtask队列：[promise1] script任务执行完毕，执行microtask checkpoint，取出microtask队列的promise1执行task队列：[setTimeout1 setTimeout2], microtask队列：[] 循环2： 从task队列中取出setTimeout1，推入栈中执行，将promise2列为microtask。task队列：[setTimeout2], microtask队列：[promise2] 执行microtask checkpoint，取出microtask队列的promise2执行。task队列：[setTimeout2], microtask队列：[] 循环3：1.从task队列中取出setTimeout2，推入栈中执行。task队列：[], microtask队列：[]2.setTimeout2任务执行完毕，执行microtask checkpoint。task队列：[], microtask队列：[] eventLoop中的Update the rendering（更新渲染）在eventLoop中的第七步会进行Update the rendering，规范允许浏览器自己选择是否更新视图。所以可能不是每轮事件循环都去更新视图，只有在必要的时候才更新视图 可阅读以下文章：浏览器的工作原理：新式网络浏览器幕后揭秘 渲染的基本流程： 处理HTML标记并构建的DOM树 处理CSS标记并构建CSSOM树，将DOM与CSSOM合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 Note：可以看到渲染树的一个重要组成部分是CSSOM树，绘制会等待css样式全部加载完成才进行，所以css样式加载的快慢是首屏呈现快慢的关键点。 验证更新渲染的时机不同机子测试可能会得到不同的结果，这取决于浏览器，cpu、gpu性能以及它们当时的状态。 例子112345678910&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var t = 0;var con = document.getElementById('con');con.onclick = function () { setTimeout(function setTimeout1 () { con.textContent = t; }, 0)};&lt;/script&gt; 用chrome的Developer tools的Timeline查看各部分运行的时间点。当我们点击这个div的时候，下图截取了部分时间线，黄色部分是脚本运行，紫色部分是更新render树、计算布局，绿色部分是绘制。 绿色和紫色部分可以认为是Update the rendering。 在这一轮事件循环中，setTimeout1是作为task运行的，可以看到paint确实是在task运行完后才进行的。 例子2现在换成一个microtask任务，看看有什么变化。 123456789&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var con = document.getElementById('con');con.onclick = function () { Promise.resolve().then(function Promise1 () { con.textContext = 0; })};&lt;/script&gt; 和上一个例子很像，不同的是这一轮事件循环的task是click的回调函数，Promise1则是microtask，paint同样是在他们之后完成。 标准就是那么定义的，答案似乎显而易见，我们把例子变得稍微复杂一些。 例子3123456789101112&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var con = document.getElementById('con');con.onclick = function click1() { setTimeout(function setTimeout1() { con.textContent = 0; }, 0) setTimeout(function setTimeout2() { con.textContent = 1; }, 0)};&lt;/script&gt; 当点击后，一共产生3个task，分别是click1、setTimeout1、setTimeout2，所以会分别在3次event loop中进行。下面截取的是setTimeout1、setTimeout2的部分。 当点击后，一共产生3个task，分别是click1、setTimeout1、setTimeout2，所以会分别在3次event loop中进行。下面截取的是setTimeout1、setTimeout2的部分。 例子4在两个setTimeout中增加microtask。 123456789101112131415161718&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var con = document.getElementById('con');con.onclick = function () { setTimeout(function setTimeout1() { con.textContent = 0; Promise.resolve().then(function Promise1 () { console.log('Promise1') }) }, 0) setTimeout(function setTimeout2() { con.textContent = 1; Promise.resolve().then(function Promise2 () { console.log('Promise2') }) }, 0)};&lt;/script&gt; 从run microtasks中可以看出来，setTimeout1、setTimeout2应该运行在两次event loop中，textContent = 0的修改被跳过了。 setTimeout1、setTimeout2的运行间隔很短，在setTimeout1完成之后，setTimeout2马上就开始执行了，我们知道浏览器会尽量保持每秒60帧的刷新频率（大约16.7ms每帧），是不是只有两次event loop间隔大于16.7ms才会进行绘制呢？ 例子5将setTimeout的时间增大些 123456789101112&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var con = document.getElementById('con');con.onclick = function () { setTimeout(function setTimeout1() { con.textContent = 0; }, 0); setTimeout(function setTimeout2() { con.textContent = 1; }, 16.7);};&lt;/script&gt; 两块黄色的区域就是 setTimeout，在1224ms处绿色部分，浏览器对con.textContent = 0的变动进行了绘制。在1234ms处绿色部分，绘制了con.textContent = 1。 可否认为相邻的两次event loop的间隔很短，浏览器就不会去更新渲染了呢？继续我们的实验 例子6我们在同一时间执行多个setTimeout来模拟执行间隔很短的task。 123456789101112131415161718192021222324252627&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var con = document.getElementById('con');con.onclick = function () { setTimeout(function(){ con.textContent = 0; },0) setTimeout(function(){ con.textContent = 1; },0) setTimeout(function(){ con.textContent = 2; },0) setTimeout(function(){ con.textContent = 3; },0) setTimeout(function(){ con.textContent = 4; },0) setTimeout(function(){ con.textContent = 5; },0) setTimeout(function(){ con.textContent = 6; },0)};&lt;/script&gt; 图中一共绘制了两帧，第一帧4.4ms，第二帧9.3ms，都远远高于每秒60HZ（16.7ms）的频率，第一帧绘制的是con.textContent = 4，第二帧绘制的是 con.textContent = 6。所以两次event loop的间隔很短同样会进行绘制。 例子7有说法是一轮event loop执行的microtask有数量限制（可能是1000），多余的microtask会放到下一轮执行。下面例子将microtask的数量增加到25000。 1234567891011121314151617&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var con = document.getElementById('con');con.onclick = function () { setTimeout(function setTimeout1() { con.textContent = 'task1'; for(var i = 0; i &lt; 250000; i++){ Promise.resolve().then(function(){ con.textContent = i; }); } }, 0); setTimeout(function setTimeout2() { con.textContent = 'task2'; }, 0);};&lt;/script&gt; 总体的timeline：可以看到一大块黄色区域，上半部分有一根绿线就是点击后的第一次绘制，脚本的运行耗费大量的时间，并且阻塞了渲染。 看看setTimeout2的运行情况。可以看到setTimeout2这轮event loop没有run microtasks，microtasks在setTimeout1被全部执行完了。 25000个microtasks不能说明event loop对microtasks数量没有限制，有可能这个限制数很高，远超25000，但日常使用基本不会使用那么多了。 对microtasks增加数量限制，一个很大的作用是防止脚本运行时间过长，阻塞渲染。 例子8使用requestAnimationFrame。 1234567891011121314151617&lt;div id='con'&gt;this is con&lt;/div&gt;&lt;script&gt;var con = document.getElementById('con');var i = 0;var raf = function(){ requestAnimationFrame(function() { con.textContent = i; Promise.resolve().then(function(){ i++; if(i &lt; 3) raf(); }); });}con.onclick = function () { raf();};&lt;/script&gt; 总体的Timeline: 点击后绘制了3帧，把每次变动都绘制了。 看看单个 requestAnimationFrame的Timeline： 和setTimeout很相似，可以看出requestAnimationFrame也是一个task，在它完成之后会运行run microtasks。 例子9验证postMessage是否是task 1234567891011121314151617181920setTimeout(function setTimeout1(){ console.log('setTimeout1')}, 0)var channel = new MessageChannel();channel.port1.onmessage = function onmessage1 (){ console.log('postMessage') Promise.resolve().then(function promise1 (){ console.log('promise1') })};channel.port2.postMessage(0);setTimeout(function setTimeout2(){ console.log('setTimeout2')}, 0)console.log('sync') 执行顺序： 12345syncpostMessagepromise1setTimeout1setTimeout2 timelime: 第一个黄块是onmessage1，第二个是setTimeout1，第三个是setTimeout2。显而易见，postMessage属于task，因为setTimeout的4ms标准化了，所以这里的postMessage会优先setTimeout运行。 小结上边的例子可以得出一些结论： 在一轮event loop中多次修改同一dom，只有最后一次会进行绘制。 渲染更新（Update the rendering）会在event loop中的tasks和microtasks完成后进行，但并不是每轮event loop都会更新渲染，这取决于是否修改了dom和浏览器觉得是否有必要在此时立即将新状态呈现给用户。如果在一帧的时间内（时间并不确定，因为浏览器每秒的帧数总在波动，16.7ms只是估算并不准确）修改了多处dom，浏览器可能将变动积攒起来，只进行一次绘制，这是合理的。 如果希望在每轮event loop都即时呈现变动，可以使用requestAnimationFrame。","link":"/2022/03/20/event-loop/"}],"tags":[{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Event-Loop","slug":"Event-Loop","link":"/tags/Event-Loop/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}