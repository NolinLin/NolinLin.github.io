{"pages":[],"posts":[{"title":"剖析Promise内部结构，手写Promise","text":"Promise标准 只有一个then方法，没有catch、race、all等方法，甚至没有指定该如何构造出一个Promise对象，另外then也没有一般实现中（如Q、$q等）所支持的第三参数，一般成为onProgress then方法返回一个新的Promise，而不是返回this 不同的Promise的实现需要可以互相调用 Promise的初始状态为pending，可以由此状态转换为fulfilled（即resolved或rejected）。状态一旦确定，就无法转换为其他状态，状态确定的过程为settle Promise标准文档 手写Promise用构造函数的方式构造一个Promise对象，也是ES6原生Promise所用方式 1234567891011121314151617181920212223function Promise(executor) { const self = this; self.status = 'pending' self.data = undefined self.onRsolvedCallback = [] self.onRejectedCallback = [] function resolved(value) { } function reject(value) { } try{ executor(resolve, reject) } catch(e) { reject(e) }} 实现 resolved 和 reject 两个函数12345678910111213141516171819202122232425function Promise(exectour) { //... function resolved(value) { if(self.status === 'pending') { self.status = 'resolved' self.data = value for(let i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](value) } } } function reject(reason) { if(self.status === 'pending') { self.status = 'rejected' self.data = reason for(let i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason) } } } //...} then方法因为调用方式为.then，所以then方法需要写在原型上。标准中then需要返回一个新的Promise对象。另外Promise对象可以链式调用then方法，所以调用then返回的Promise状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为每次返回的Promise状态都有可能不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Promise.prototype.then = function(onResolved, onRejected) { const self = this const promise2 = null //根据标准，如果then的参数不是function，则直接忽略 onResolved = typeof onResolved === 'function' ? onResolved : function(value) {} onRejected = typeof onRejected === 'function' ? onRejected : function(value) {} if(self.status === 'resolved') { return promise2 = new Promise(function(resolve, reject)) { try { const x = onResolved(self.data) if(x instanceof Promise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果为promise2的结果 x.then(resolve, reject) } // 否则，以它的返回值做为promise2的结果 resolve(x) } catch (e) { // 若出错，以捕获的错误做为promise2的结果 reject(e) } } } // 此处与resolve的逻辑几乎相同 if(self.status === 'rejected') { return promise2 = new Promise(function(resolve, reject) { try { const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) } if(self.status === 'pending') { // 如果当前Promise还处于pending状态，并不能确定调用onResolve还是onRejected，只能等到Promise的状态确定之后，才能确定如何处理。 // 所以我们需要把我们的两种情况的处理逻辑做为callback 放入 promise1的回调数组里 return promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { const x = onResolved(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) self.onRejectedCallback.push(function(reason) { try{ const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch (e) { reject(e) } }) }) }} 处理两个问题1、Promise值的穿透，例如： 123456new Promise(resolve =&gt; resolve(8)) .then() .catch() .then(function foo(value) { alter(value) }) 解决方案：以上代码转换为： 12345678910new Promise（resolve =&gt; resolve(8)） .then(function(value) { return value }) .catch(function(reason) { throw reason }) .then(function foo(value) { alter(value) }) 若想要把then的实参，留空且让值穿透，只需要修改then的两个参数默认值分别如下： 1function(value) { return value }, function(reason) { return reason }; 体现到then，则如下： 12onResolved = typeof onResolved === 'function' ? onResolved : function(value) { return value }onRejected = typeof onRejected === 'function' ? onRejected : function(reason) { throw reason } 2、不同的Promise实现之间需要无缝的可交互，如： 12345678910111213141516// 此处用MyPromise来代表我们实现的Promisenew MyPromise(function(resolve, reject) { // 我们实现的Promise setTimeout(function() { resolve(42) }, 2000)}).then(() =&gt; { return new Promise.reject(2) // ES6的Promise}).then(function() { return Q.all([ // Q的Promise new MyPromise(resolve =&gt; resolve(8)); // 我们实现的Promise new Promise.resolve(9); // ES6的Promise Q.resolve(9); // Q的Promise ])}) 这里简单解释下标准：即我们要把onResolved/onRejected的返回值——x，当成一个可能是Promise对象，也即标准里所说的thenable，并以最保险的方法调用x上的then方法，如果大家都按照标准实现，那么不同的Promise之间就可以交互了。而标准为了保险起见，即使x返回了一个带有then属性，但并不遵循Promise标准的对象（比如说这个x把它then里的两个参数都调用了，同步或者异步调用，或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。 resolvePromise函数即为根据x的值来决定promise2的状态的函数，也即标准中的Promise Resolution Procedurex为promise2 = promise1.then(onResolved, onRejected)里onResolved/onRejected的返回值，resolve和reject实际上是promise2的executor的两个实参，因为很难挂在其它的地方，所以一并传进来。相信各位一定可以对照标准把标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function resolvePromise(promise2, x, resolve, reject) { var then var thenCalledOrThrow = false if (promise2 === x) { // 对应标准2.3.1节 return reject(new TypeError('Chaining cycle detected for promise!')) } if(x instanceof Promise) { // 对应标准2.3.2节 // 如果x的状态还没确定，那么它是有可能被一个thenable决定最终状态和值的 // 所以这里需要做一下处理，而不能一概的以为它会被一个“正常”的值resolve if(x.status === 'pending') { x.then(function(value) { resolvePromise(promise2, value, resolve, reject) }, reject) } else { // 但如果这个Promise的状态已经确定了，那么它肯定有一个“正常”的值，而不是一个thenable，所以这里直接取它的状态 x.then(resolve, reject) } return } if ((x !== null) &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) { // 2.3.3 try { // 2.3.3.1 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用 // 即要判断它的类型，又要调用它，这就是两次读取 then = x.then if (typeof then === 'function') { // 2.3.3.3 then.call(x, function rs(y) { // 2.3.3.3.1 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return resolvePromise(promise2, y, resolve, reject) // 2.3.3.3.1 }, function rj(r) { // 2.3.3.3.2 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return reject(r) }) } else { // 2.3.3.4 resolve(x) } } catch (e) { // 2.3.3.2 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return reject(e) } } else { // 2.3.4 resolve(x) }} 最后，原则上，promise.then(onResolved, onRejected)里的这两项函数需要异步调用，关于这一点，标准里也有说明：In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack.所以我们需要对代码做一些改动，即在四个地方加上setTimeout(fn, 0), 这点会在完整的代码中注释。 至此，已经完整实现一个Promise，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165try { module.exports = Promise} catch(e) {}function Promise(executor) { var self = this self.status = 'pending' self.onResolvedCallback = [] self.onRejectedCallback = [] function resolve(value) { if(value instanceof Promise) { return value.then(resolve, reject) } setTimeout(function() { if(self.status === 'pending') { self.status = 'resolved' self.data = value for(var i = 0; i &lt; self.onResolvedCallback; i++) { self.onResolvedCallback[i](value) } } }) } function reject(reason) { setTimeout(() =&gt; { if(self.status === 'pending') { self.status = 'rejected' self.data = reason for(var i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason) } } }) } try{ executor(resolve, reject) } catch(reason) { reject(reason) }}function resolvePromise(promise2, x, resolve, reject) { var then var thenCalledOrThrow = false if (promise2 === x) { return reject(new TypeError('Chaining cycle detected for promise!')) } if (x instanceof Promise) { if (x.status === 'pending') { //because x could resolved by a Promise Object x.then(function(v) { resolvePromise(promise2, v, resolve, reject) }, reject) } else { //but if it is resolved, it will never resolved by a Promise Object but a static value; x.then(resolve, reject) } return } if ((x !== null) &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) { try { then = x.then //because x.then could be a getter if (typeof then === 'function') { then.call(x, function rs(y) { if (thenCalledOrThrow) return thenCalledOrThrow = true return resolvePromise(promise2, y, resolve, reject) }, function rj(r) { if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(r) }) } else { resolve(x) } } catch (e) { if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(e) } } else { resolve(x) }}Promise.prototype.then = function(onResolved, onRejected) { var self = this var promise2 onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return v } onRejected = typeof onRejected === 'function' ? onRejected : function(r) { throw r } if (self.status === 'resolved') { return promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onResolved try { var x = onResolved(self.data) resolvePromise(promise2, x, resolve, reject) } catch (reason) { reject(reason) } }) }) } if (self.status === 'rejected') { return promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onRejected try { var x = onRejected(self.data) resolvePromise(promise2, x, resolve, reject) } catch (reason) { reject(reason) } }) }) } if (self.status === 'pending') { // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义 return promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { var x = onResolved(value) resolvePromise(promise2, x, resolve, reject) } catch (r) { reject(r) } }) self.onRejectedCallback.push(function(reason) { try { var x = onRejected(reason) resolvePromise(promise2, x, resolve, reject) } catch (r) { reject(r) } }) }) }}Promise.prototype.catch = function(onRejected) { return this.then(null, onRejected)}Promise.deferred = Promise.defer = function() { var dfd = {} dfd.promise = new Promise(function(resolve, reject) { dfd.resolve = resolve dfd.reject = reject }) return dfd} 最后我们来用20行写出一个简易版的Promise，支持异步链式调用 12345678910111213141516171819202122232425function Promise(fn) { this.cbs = []; const resolve = (value) =&gt; { setTimeout(() =&gt; { this.data = value; this.cbs.forEach((cb) =&gt; cb(value)); }); } fn(resolve);}Promise.prototype.then = function (onResolved) { return new Promise((resolve) =&gt; { this.cbs.push(() =&gt; { const res = onResolved(this.data); if (res instanceof Promise) { res.then(resolve); } else { resolve(res); } }); });}; 案例 1234567891011121314new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(1); }, 500);}) .then((res) =&gt; { console.log(res); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(2); }, 500); }); }) .then(console.log);","link":"/2022/03/09/Handwritten-Promise/"}],"tags":[],"categories":[]}