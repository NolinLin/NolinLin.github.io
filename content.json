{"pages":[],"posts":[{"title":"剖析Promise内部结构，手写Promise","text":"Promise标准 只有一个then方法，没有catch、race、all等方法，甚至没有指定该如何构造出一个Promise对象，另外then也没有一般实现中（如Q、$q等）所支持的第三参数，一般成为onProgress then方法返回一个新的Promise，而不是返回this 不同的Promise的实现需要可以互相调用 Promise的初始状态为pending，可以由此状态转换为fulfilled（即resolved或rejected）。状态一旦确定，就无法转换为其他状态，状态确定的过程为settle Promise标准文档 手写Promise用构造函数的方式构造一个Promise对象，也是ES6原生Promise所用方式 1234567891011121314151617181920212223function Promise(executor) { const self = this; self.status = 'pending' self.data = undefined self.onRsolvedCallback = [] self.onRejectedCallback = [] function resolved(value) { } function reject(value) { } try{ executor(resolve, reject) } catch(e) { reject(e) }} 实现 resolved 和 reject 两个函数12345678910111213141516171819202122232425function Promise(exectour) { //... function resolved(value) { if(self.status === 'pending') { self.status = 'resolved' self.data = value for(let i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](value) } } } function reject(reason) { if(self.status === 'pending') { self.status = 'rejected' self.data = reason for(let i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason) } } } //...} then方法因为调用方式为.then，所以then方法需要写在原型上。标准中then需要返回一个新的Promise对象。另外Promise对象可以链式调用then方法，所以调用then返回的Promise状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为每次返回的Promise状态都有可能不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Promise.prototype.then = function(onResolved, onRejected) { const self = this const promise2 = null //根据标准，如果then的参数不是function，则直接忽略 onResolved = typeof onResolved === 'function' ? onResolved : function(value) {} onRejected = typeof onRejected === 'function' ? onRejected : function(value) {} if(self.status === 'resolved') { return promise2 = new Promise(function(resolve, reject)) { try { const x = onResolved(self.data) if(x instanceof Promise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果为promise2的结果 x.then(resolve, reject) } // 否则，以它的返回值做为promise2的结果 resolve(x) } catch (e) { // 若出错，以捕获的错误做为promise2的结果 reject(e) } } } // 此处与resolve的逻辑几乎相同 if(self.status === 'rejected') { return promise2 = new Promise(function(resolve, reject) { try { const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) } if(self.status === 'pending') { // 如果当前Promise还处于pending状态，并不能确定调用onResolve还是onRejected，只能等到Promise的状态确定之后，才能确定如何处理。 // 所以我们需要把我们的两种情况的处理逻辑做为callback 放入 promise1的回调数组里 return promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { const x = onResolved(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) self.onRejectedCallback.push(function(reason) { try{ const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch (e) { reject(e) } }) }) }}","link":"/2022/03/09/Handwritten-Promise/"}],"tags":[],"categories":[]}