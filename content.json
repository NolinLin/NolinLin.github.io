{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"剖析Promise内部结构，手写Promise","text":"Promise标准 只有一个then方法，没有catch、race、all等方法，甚至没有指定该如何构造出一个Promise对象，另外then也没有一般实现中（如Q、$q等）所支持的第三参数，一般成为onProgress then方法返回一个新的Promise，而不是返回this 不同的Promise的实现需要可以互相调用 Promise的初始状态为pending，可以由此状态转换为fulfilled（即resolved或rejected）。状态一旦确定，就无法转换为其他状态，状态确定的过程为settle Promise标准文档 手写Promise用构造函数的方式构造一个Promise对象，也是ES6原生Promise所用方式 1234567891011121314151617181920212223function Promise(executor) { const self = this; self.status = 'pending' self.data = undefined self.onRsolvedCallback = [] self.onRejectedCallback = [] function resolved(value) { } function reject(value) { } try{ executor(resolve, reject) } catch(e) { reject(e) }} 实现 resolved 和 reject 两个函数12345678910111213141516171819202122232425function Promise(exectour) { //... function resolved(value) { if(self.status === 'pending') { self.status = 'resolved' self.data = value for(let i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](value) } } } function reject(reason) { if(self.status === 'pending') { self.status = 'rejected' self.data = reason for(let i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason) } } } //...} then方法因为调用方式为.then，所以then方法需要写在原型上。标准中then需要返回一个新的Promise对象。另外Promise对象可以链式调用then方法，所以调用then返回的Promise状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为每次返回的Promise状态都有可能不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Promise.prototype.then = function(onResolved, onRejected) { const self = this const promise2 = null //根据标准，如果then的参数不是function，则直接忽略 onResolved = typeof onResolved === 'function' ? onResolved : function(value) {} onRejected = typeof onRejected === 'function' ? onRejected : function(value) {} if(self.status === 'resolved') { return promise2 = new Promise(function(resolve, reject)) { try { const x = onResolved(self.data) if(x instanceof Promise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果为promise2的结果 x.then(resolve, reject) } // 否则，以它的返回值做为promise2的结果 resolve(x) } catch (e) { // 若出错，以捕获的错误做为promise2的结果 reject(e) } } } // 此处与resolve的逻辑几乎相同 if(self.status === 'rejected') { return promise2 = new Promise(function(resolve, reject) { try { const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) } if(self.status === 'pending') { // 如果当前Promise还处于pending状态，并不能确定调用onResolve还是onRejected，只能等到Promise的状态确定之后，才能确定如何处理。 // 所以我们需要把我们的两种情况的处理逻辑做为callback 放入 promise1的回调数组里 return promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { const x = onResolved(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch(e) { reject(e) } }) self.onRejectedCallback.push(function(reason) { try{ const x = onRejected(self.data) if(x instanceof Promise) { x.then(resolve, reject) } } catch (e) { reject(e) } }) }) }} 处理两个问题1、Promise值的穿透，例如： 123456new Promise(resolve =&gt; resolve(8)) .then() .catch() .then(function foo(value) { alter(value) }) 解决方案：以上代码转换为： 12345678910new Promise（resolve =&gt; resolve(8)） .then(function(value) { return value }) .catch(function(reason) { throw reason }) .then(function foo(value) { alter(value) }) 若想要把then的实参，留空且让值穿透，只需要修改then的两个参数默认值分别如下： 1function(value) { return value }, function(reason) { return reason }; 体现到then，则如下： 12onResolved = typeof onResolved === 'function' ? onResolved : function(value) { return value }onRejected = typeof onRejected === 'function' ? onRejected : function(reason) { throw reason } 2、不同的Promise实现之间需要无缝的可交互，如： 12345678910111213141516// 此处用MyPromise来代表我们实现的Promisenew MyPromise(function(resolve, reject) { // 我们实现的Promise setTimeout(function() { resolve(42) }, 2000)}).then(() =&gt; { return new Promise.reject(2) // ES6的Promise}).then(function() { return Q.all([ // Q的Promise new MyPromise(resolve =&gt; resolve(8)); // 我们实现的Promise new Promise.resolve(9); // ES6的Promise Q.resolve(9); // Q的Promise ])}) 这里简单解释下标准：即我们要把onResolved/onRejected的返回值——x，当成一个可能是Promise对象，也即标准里所说的thenable，并以最保险的方法调用x上的then方法，如果大家都按照标准实现，那么不同的Promise之间就可以交互了。而标准为了保险起见，即使x返回了一个带有then属性，但并不遵循Promise标准的对象（比如说这个x把它then里的两个参数都调用了，同步或者异步调用，或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。 resolvePromise函数即为根据x的值来决定promise2的状态的函数，也即标准中的Promise Resolution Procedurex为promise2 = promise1.then(onResolved, onRejected)里onResolved/onRejected的返回值，resolve和reject实际上是promise2的executor的两个实参，因为很难挂在其它的地方，所以一并传进来。相信各位一定可以对照标准把标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function resolvePromise(promise2, x, resolve, reject) { var then var thenCalledOrThrow = false if (promise2 === x) { // 对应标准2.3.1节 return reject(new TypeError('Chaining cycle detected for promise!')) } if(x instanceof Promise) { // 对应标准2.3.2节 // 如果x的状态还没确定，那么它是有可能被一个thenable决定最终状态和值的 // 所以这里需要做一下处理，而不能一概的以为它会被一个“正常”的值resolve if(x.status === 'pending') { x.then(function(value) { resolvePromise(promise2, value, resolve, reject) }, reject) } else { // 但如果这个Promise的状态已经确定了，那么它肯定有一个“正常”的值，而不是一个thenable，所以这里直接取它的状态 x.then(resolve, reject) } return } if ((x !== null) &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) { // 2.3.3 try { // 2.3.3.1 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用 // 即要判断它的类型，又要调用它，这就是两次读取 then = x.then if (typeof then === 'function') { // 2.3.3.3 then.call(x, function rs(y) { // 2.3.3.3.1 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return resolvePromise(promise2, y, resolve, reject) // 2.3.3.3.1 }, function rj(r) { // 2.3.3.3.2 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return reject(r) }) } else { // 2.3.3.4 resolve(x) } } catch (e) { // 2.3.3.2 if (thenCalledOrThrow) return // 2.3.3.3.3 即这三处谁选执行就以谁的结果为准 thenCalledOrThrow = true return reject(e) } } else { // 2.3.4 resolve(x) }} 最后，原则上，promise.then(onResolved, onRejected)里的这两项函数需要异步调用，关于这一点，标准里也有说明：In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack.所以我们需要对代码做一些改动，即在四个地方加上setTimeout(fn, 0), 这点会在完整的代码中注释。 至此，已经完整实现一个Promise，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165try { module.exports = Promise} catch(e) {}function Promise(executor) { var self = this self.status = 'pending' self.onResolvedCallback = [] self.onRejectedCallback = [] function resolve(value) { if(value instanceof Promise) { return value.then(resolve, reject) } setTimeout(function() { if(self.status === 'pending') { self.status = 'resolved' self.data = value for(var i = 0; i &lt; self.onResolvedCallback; i++) { self.onResolvedCallback[i](value) } } }) } function reject(reason) { setTimeout(() =&gt; { if(self.status === 'pending') { self.status = 'rejected' self.data = reason for(var i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason) } } }) } try{ executor(resolve, reject) } catch(reason) { reject(reason) }}function resolvePromise(promise2, x, resolve, reject) { var then var thenCalledOrThrow = false if (promise2 === x) { return reject(new TypeError('Chaining cycle detected for promise!')) } if (x instanceof Promise) { if (x.status === 'pending') { //because x could resolved by a Promise Object x.then(function(v) { resolvePromise(promise2, v, resolve, reject) }, reject) } else { //but if it is resolved, it will never resolved by a Promise Object but a static value; x.then(resolve, reject) } return } if ((x !== null) &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) { try { then = x.then //because x.then could be a getter if (typeof then === 'function') { then.call(x, function rs(y) { if (thenCalledOrThrow) return thenCalledOrThrow = true return resolvePromise(promise2, y, resolve, reject) }, function rj(r) { if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(r) }) } else { resolve(x) } } catch (e) { if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(e) } } else { resolve(x) }}Promise.prototype.then = function(onResolved, onRejected) { var self = this var promise2 onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return v } onRejected = typeof onRejected === 'function' ? onRejected : function(r) { throw r } if (self.status === 'resolved') { return promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onResolved try { var x = onResolved(self.data) resolvePromise(promise2, x, resolve, reject) } catch (reason) { reject(reason) } }) }) } if (self.status === 'rejected') { return promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onRejected try { var x = onRejected(self.data) resolvePromise(promise2, x, resolve, reject) } catch (reason) { reject(reason) } }) }) } if (self.status === 'pending') { // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义 return promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { var x = onResolved(value) resolvePromise(promise2, x, resolve, reject) } catch (r) { reject(r) } }) self.onRejectedCallback.push(function(reason) { try { var x = onRejected(reason) resolvePromise(promise2, x, resolve, reject) } catch (r) { reject(r) } }) }) }}Promise.prototype.catch = function(onRejected) { return this.then(null, onRejected)}Promise.deferred = Promise.defer = function() { var dfd = {} dfd.promise = new Promise(function(resolve, reject) { dfd.resolve = resolve dfd.reject = reject }) return dfd} 最后我们来用20行写出一个简易版的Promise，支持异步链式调用 12345678910111213141516171819202122232425function Promise(fn) { this.cbs = []; const resolve = (value) =&gt; { setTimeout(() =&gt; { this.data = value; this.cbs.forEach((cb) =&gt; cb(value)); }); } fn(resolve);}Promise.prototype.then = function (onResolved) { return new Promise((resolve) =&gt; { this.cbs.push(() =&gt; { const res = onResolved(this.data); if (res instanceof Promise) { res.then(resolve); } else { resolve(res); } }); });}; 案例 1234567891011121314new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(1); }, 500);}) .then((res) =&gt; { console.log(res); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(2); }, 500); }); }) .then(console.log);","link":"/2022/03/09/Handwritten-Promise/"},{"title":"理解JavaScript之EventLoop","text":"前言异步背后的“靠山”就是Event Loop。这里的异步准确的说叫浏览器的Event Loop或者JavaScript运行环境的Event Loop，因为ECMAScript中没有Event Loop，Event Loop是在HTML Standard定义的。Event Loop是浏览器或Node解决单线程运行时不会阻塞的一种机制。规范中定义了浏览器何时进行渲染更新，了解它有助于性能优化. 定义Event Loop即事件循环，实现异步的一种方式。在HTML Standard中的定义章节： 为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用本节所述的event loop。 触发一个click事件，进行一次ajax请求，背后都有event loop在运作。 Task（macrotask， 宏任务） 一个Event Loop有一个或者多个task队列当用户代理安排一个任务，必须将该任务增加到相应的Event Loop的一个task队列中。每一个task都来源于指定的任务源，比如可以为鼠标、键盘事件提供一个task队列，其他时间又是一个单独的队列。可以为鼠标，键盘事件分配更多的时间，保证交互的流畅。 规范在Generic task sources中有提及哪些是task任务源： DOM操作任务源，用于相应dom操作，例如一个元素以非阻塞的方式插入文档。 用户交互任务源，用于对用户交互作出反应，例如键盘或鼠标输入。 网络任务源：用于相应网络活动。 history traversal 任务源，当调用history.back()等类似的api时，将任务插入task队列 总结，task任务源有哪些： setTimeout setInterval setImmediate I/O UI rendering microtask（微任务）每个Event Loop都有一个microtask队列，microtask会进入microtask队列，而不是task队列 如果在初期执行时，spin the event loop，microtasks有可能被移动到常规的task队列，在这种情况下，microtasks任务源会被task任务源所用。通常情况，task任务源和microtasks是不相关的。 microtask 和 macrotask队列相似之处：都是先进先出的队列，由指定任务源去提供任务。不同的是，一个Event Loop里只有一个microtask队列。 HTML Standard没有具体指明哪些是microtask任务源，通常认为是microtask任务源有： process.nextTick promises Object.observe MutationObserver Notes：在Promises/A+规范的Notes 3.1中提及了Promise的then方法可以采用macrotask 或者 microtask机制来实现。因此会产生promise在不同浏览器的差异。当然现在的共识都是 promise 都属于 microtask 队列。 深入了解有两种Event Loop，一种在浏览器上文，一种在workers中。每一个用户代理必须至少有一个浏览器上下文Event Loop，但是每个单元的相似源浏览器上下文至多有一个Event Loop。Event Loop总是具有至少一个浏览器上下文，当一个Event Loop的浏览器上下文全都销毁，Event Loop也会销毁。一个浏览器上下文总有一个Event Loop去协调它的活动。Worker的Event Loop相对简单一些，一个Worker对应一个Event Loop，Worker进程模型管理Event Loop的生命周期 浏览器上下文是一个将Document对象呈现给用户的环境。在一个Web浏览器内，一个标签页或窗口常包含一个浏览上下文，如一个iframe或一个frameset内的若干frame。 总结：每个线程都有自己的Event Loop。浏览器可以有多个Event Loop，Browsing Contexts和Web Workers就是相互独立的.所有同源的Browsing Contexts可以共用Event Loop，这样它们就可以互相通信。 Event Loop的循环过程在规范的Processing model定义了Event Loop的循环过程 在tasks队列中选择最老的一个task，用户代理可以选择任何task队列，如果没有可选的任务，则跳到下边的microtask步骤。 将上边选择的task设置为正在运行的task。 Run：运行被选择的task。 将Event Loop的currently running task 变为null。 从task队列里移除前边运行的task。 执行microtasks任务检查点。 更新渲染。 如果这是一个Worker EventLoop，但是没有任务在task队列中，并且WorkerGlobalScope对象的closing标识为true，则销毁event loop，中止这些步骤，然后进行定义在Web workers章节的run a worker。 返回第一步。 notes:执行完microtask队列里的任务，有可能会渲染更新。浏览器很聪明，在一帧以内的多次dom变动浏览器不会立即响应，而是会积攒变动以最高60HZ的频率更新视图。 microtask检查点以下为event loop运行第6步的详细步骤。 当用户代理去执行一个microtask checkpoint，如果microtask checkpoint的flag为false，用户代理必须运行下面的步骤： 将microtask checkpoint的flag设为true。 Microtask queue handling: 如果Event Loop的microtask为空，直接跳到第八步。 在microtask队列中选择最老的一个任务。 将上一步选择的任务设为Event Loop的currently running task 运行选择的任务。 将Event Loop的currently running task 变为null。 将前面运行的microtask从microtask队列中删除，然后返回第二步。 Done： 每一个environment settings object它们的 responsible event loop就是当前的event loop，会给environment settings object发一个 rejected promises 的通知。 清理IndexedDB的事务。 将microtask checkpoint的flag设为false。 什么时候会调用microtask checkpoint呢？ 当上下文执行栈为空，执行一个microtask checkpoint。 在Event Loop的第六步执行checkpoint，也就是在运行task之后，更新渲染之前。 执行栈task和microtask都是推入栈中执行的，要完整了解event loops还需要认识JavaScript execution context stack，它的规范位于https://tc39.github.io/ecma262/#execution-context-stack。 javaScript是单线程，也就是说只有一个主线程，主线程有一个栈，每一个函数执行的时候，都会生成新的execution context（执行上下文），执行上下文会包含一些当前函数的参数、局部变量之类的信息，它会被推入栈中， running execution context（正在执行的上下文）始终处于栈的顶部。当函数执行完后，它的执行上下文会从栈弹出。 完整异步过程打个比喻：主线程类似一个加工厂，只有一个条流水线（单线程），待执行的任务为原料，只有前一个加工完，才能进行后一个。eventLoop就是把原料放上流水线的工人。同步任务：只要已经放在流水线上的，它们会被依次处理。异步任务：待处理的原料，工人会按照它们的种类排序，在适当的时机放上流水线。 过程图： 举个栗子： 123456789101112131415Promise.resolve().then(function promise1() { console.log('promise1');})setTimeout(function() { console.log('setTimeout1'); Promise.resolve().then(function promise2() { console.log('promise2'); })}, 0)setTimeout(function setTimeout2() { console.log('setTimeout2')}, 0) 运行过程解析：第一步： task队列: [scipt]，microtask队列: [] script里的代码被列为一个task，放入task队列。 第二步：开始循环 循环1： 1. 从task队列中取出script任务，推入栈中执行。promise1列为microtask，setTimeout1列为task，setTimeout2列为task。 task队列：[setTimeout1 setTimeout2], microtask队列：[promise1] 2. script任务执行完毕，执行microtask checkpoint，取出microtask队列的promise1执行 task队列：[setTimeout1 setTimeout2], microtask队列：[] 循环2： 1. 从task队列中取出setTimeout1，推入栈中执行，将promise2列为microtask。 task队列：[setTimeout2], microtask队列：[promise2] 2. 执行microtask checkpoint，取出microtask队列的promise2执行。 task队列：[setTimeout2], microtask队列：[] 循环3： 1.从task队列中取出setTimeout2，推入栈中执行。 task队列：[], microtask队列：[] 2.setTimeout2任务执行完毕，执行microtask checkpoint。 task队列：[], microtask队列：[]","link":"/2022/03/20/event-loop/"}],"tags":[{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Event-Loop","slug":"Event-Loop","link":"/tags/Event-Loop/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}